[gd_resource type="Shader" format=2]

[resource]
code = "shader_type spatial;
render_mode unshaded, depth_draw_alpha_prepass;

varying vec2 size;

void vertex() {
	vec3 p = VERTEX;
	
	vec2 scl = UV / VIEWPORT_SIZE;
	scl.y *= VIEWPORT_SIZE.y / VIEWPORT_SIZE.x;
	
	p = (INV_CAMERA_MATRIX * vec4(p, 1.0)).xyz;
	
	if (PROJECTION_MATRIX[3][3] != 0.0) {
		float h = abs(1.0 / (2.0 * PROJECTION_MATRIX[1][1]));
		float sc = (h * 2.0); //consistent with Y-fov
		scl *= sc;
	} else {
		scl *= -p.z;
	}
	
	p.xy += scl;
	
	POSITION = PROJECTION_MATRIX * vec4(p, 1.0);
	
	float r = length(scl);
	
	size = vec2(r);
	UV = UV / abs(UV);
}

void fragment() {
	vec2 p = UV * size;
	float r = min(size.x, size.y);
	vec2 b = size - r;
	vec2 d = abs(p) - b;
	float dst1 = min(max(d.x, d.y), 0.0);
	float dst2 = length(max(d, 0.0));
	float dst = (dst1 + dst2) - r;
	
	ALPHA = step(dst, 0.0);
	ALBEDO *= COLOR.rgb;
	ALPHA *= COLOR.a;
}




"
