[gd_resource type="Shader" format=2]

[resource]
code = "shader_type spatial;
render_mode unshaded;

varying vec2 size;

void clip_line(inout vec4 a, inout vec4 b, int plane) {
	/*float ad = a.z + a.w;
	float bd = b.z + b.w;*/
	float ad, bd;
	switch (plane) {
		case 0: {
			ad = a.x + a.w;
			bd = b.x + b.w;
		} break;
		case 1: {
			ad = -a.x + a.w;
			bd = -b.x + b.w;
		} break;
		case 2: {
			ad = a.y + a.w;
			bd = b.y + b.w;
		} break;
		case 3: {
			ad = -a.y + a.w;
			bd = -b.y + b.w;
		} break;
		case 4: {
			ad = a.z + a.w;
			bd = b.z + b.w;
		} break;
		case 5: {
			ad = -a.z + a.w;
			bd = -b.z + b.w;
		} break;
	}
	
	a = ad < 0.0 && bd < 0.0 ? vec4(0.0, 0.0, 2.0, 1.0) : a;
	b = ad < 0.0 && bd < 0.0 ? vec4(0.0, 0.0, 2.0, 1.0) : b;
	
	float at = ad / (ad - bd);
	float bt = bd / (bd - ad);
	
	a = ad < 0.0 ? a + (b - a) * at : a;
	b = bd < 0.0 ? b + (a - b) * bt : b;
}

void vertex() {
	vec4 p0 = vec4(VERTEX, 1.0);
	vec4 p1 = vec4(VERTEX + NORMAL, 1.0);
	
	float r0 = UV2.x * 0.5;
	float r1 = UV2.y * 0.5;
	float r = max(r0, r1);
	
	p0 = PROJECTION_MATRIX * INV_CAMERA_MATRIX * p0;
	p1 = PROJECTION_MATRIX * INV_CAMERA_MATRIX * p1;
	
	clip_line(p0, p1, 0);
	clip_line(p0, p1, 1);
	clip_line(p0, p1, 2);
	clip_line(p0, p1, 3);
	clip_line(p0, p1, 4);
	clip_line(p0, p1, 5);
	
	p0.xyz /= p0.w;
	p1.xyz /= p1.w;
	
	p0.w = 1.0;
	p1.w = 1.0;
	
	p0.y = -p0.y;
	p1.y = -p1.y;
	p0.xy = (p0.xy * 0.5 + 0.5) * VIEWPORT_SIZE;
	p1.xy = (p1.xy * 0.5 + 0.5) * VIEWPORT_SIZE;
	
	vec3 off = p1.xyz - p0.xyz;
	vec2 sx = normalize(off.xy) * r;
	vec2 sy = vec2(-sx.y, sx.x);
	
	sx *= sign(UV.x);
	sy *= sign(UV.y);
	
	float l = length(off.xy);
	
	vec4 p = p0;
	p.xyz += off * max(sign(UV.x), 0.0);
	
	p.xy += (sx + sy);
	
	p.xy = (p.xy / VIEWPORT_SIZE) * 2.0 - 1.0;
	p.y = -p.y;
	
	POSITION = p;
	
	size = vec2(l * 0.5 + r, r);
}

void fragment() {
	float r0 = UV2.x * 0.5;
	float r1 = UV2.y * 0.5;
	
	vec2 p = UV * size;
	vec2 p0 = vec2(-(size.x - size.y), 0.0);
	vec2 p1 = vec2(size.x - size.y, 0.0);
	
	vec2 ba = p1 - p0;
	vec2 ca = p - p0;
	float t = dot(ca, ba) / dot(ba, ba);
	t = clamp(t, 0.0, 1.0);
	vec2 p2 = p0 + ba * t;
	float r = r0 + (r1 - r0) * t;
	
	vec2 off = p2 - p;
	float d = sqrt(off.x * off.x + off.y * off.y) - r;
	
	ALPHA = -d;
	ALBEDO *= COLOR.rgb;
	ALPHA_SCISSOR = 0.0;
}




"
