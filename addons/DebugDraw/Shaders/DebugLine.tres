[gd_resource type="Shader" format=2]

[resource]
code = "shader_type spatial;
render_mode unshaded, depth_draw_alpha_prepass;

varying vec2 size;

void clip_line(inout vec4 a, inout vec4 b, float near) {
	float ta = (a.w - near) / ((a.w - near) - (b.w - near));
	float tb = (b.w - near) / ((b.w - near) - (a.w - near));
	vec4 at = a;
	vec4 bt = b;
	if (a.w < 0.0) {
		a += ta * (b - a);
	}
	if (b.w < 0.0) {
		b += tb * (a - b);
	}
}

void vertex() {
	vec3 wpa = VERTEX;
	vec3 wpb = VERTEX + NORMAL;
	
	float x_asp = VIEWPORT_SIZE.x / VIEWPORT_SIZE.y;
	float y_asp = VIEWPORT_SIZE.y / VIEWPORT_SIZE.x;
	
	vec2 scl = vec2(1.0) / VIEWPORT_SIZE;
	scl.y *= VIEWPORT_SIZE.y / VIEWPORT_SIZE.x;
	
	vec4 cpa = vec4(wpa, 1.0);
	vec4 cpb = vec4(wpb, 1.0);
	
	cpa = INV_CAMERA_MATRIX * cpa;
	cpb = INV_CAMERA_MATRIX * cpb;
	
	cpa = PROJECTION_MATRIX * cpa;
	cpb = PROJECTION_MATRIX * cpb;
	
	float near = PROJECTION_MATRIX[3].z / (PROJECTION_MATRIX[2].z - 1.0);
	
	clip_line(cpa, cpb, near);
	
	cpa.xyz /= cpa.w;
	cpb.xyz /= cpb.w;
	
	cpa.w = 1.0;
	cpb.w = 1.0;
	
	vec3 off = cpb.xyz - cpa.xyz;
	vec2 sx = off.xy;
	sx.y *= y_asp;
	sx = normalize(sx);
	sx.x *= y_asp;
	vec2 sy = vec2(-sx.y, sx.x);
	sy.x *= y_asp;
	sy.y *= x_asp;
	
	sx *= scl * UV.x;
	sy *= scl * UV.y;
	
	vec4 p = cpa;
	p.xyz += off * max(sign(UV.x), 0.0);
	p.xy += (sx + sy);
	
	POSITION = p;
	
	sy.x *= x_asp;
	sy.y *= y_asp;
	
	float l = length(off.xy);
	float r = length(sy);
	
	size = vec2(l * 0.5 + r, r);
	UV = UV / (abs(UV));
}

void fragment() {
	vec2 p = UV * size;
	float r = min(size.x, size.y);
	vec2 b = size - r;
	vec2 d = abs(p) - b;
	float dst1 = min(max(d.x, d.y), 0.0);
	float dst2 = length(max(d, 0.0));
	float dst = (dst1 + dst2) - r;
	
	//dst = length(UV) - 1.0;
	
	ALPHA = -dst;
	ALBEDO *= COLOR.rgb;
	ALPHA_SCISSOR = 0.0;
}




"
