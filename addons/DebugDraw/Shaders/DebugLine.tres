[gd_resource type="Shader" format=2]

[resource]
code = "shader_type spatial;
render_mode unshaded;

varying vec2 size;

void clip_line(inout vec4 a, inout vec4 b, vec4 plane) {
	float aw = dot(a.xyz, plane.xyz) + plane.w;
	float bw = dot(b.xyz, plane.xyz) + plane.w;
	
	a = (aw < 0.0 && bw < 0.0) ? vec4(0.0, 0.0, 1.0, 1.0) : a;
	b = (aw < 0.0 && bw < 0.0) ? vec4(0.0, 0.0, 1.0, 1.0) : b;
	
	float at = aw / (aw - bw);
	float bt = bw / (bw - aw);
	
	a = aw < 0.0 ? a + (b - a) * at : a;
	b = bw < 0.0 ? b + (a - b) * bt : b;
}

void vertex() {
	vec4 p0 = vec4(VERTEX, 1.0);
	vec4 p1 = vec4(VERTEX + NORMAL, 1.0);
	
	float rad = UV2.x * 0.5;
	
	p0 = INV_CAMERA_MATRIX * p0;
	p1 = INV_CAMERA_MATRIX * p1;
	
	vec4 left = vec4(
		PROJECTION_MATRIX[0][3] + PROJECTION_MATRIX[0][0],
		PROJECTION_MATRIX[1][3] + PROJECTION_MATRIX[1][0],
		PROJECTION_MATRIX[2][3] + PROJECTION_MATRIX[2][0],
		PROJECTION_MATRIX[3][3] + PROJECTION_MATRIX[3][0]
	);
	vec4 right = vec4(
		PROJECTION_MATRIX[0][3] - PROJECTION_MATRIX[0][0],
		PROJECTION_MATRIX[1][3] - PROJECTION_MATRIX[1][0],
		PROJECTION_MATRIX[2][3] - PROJECTION_MATRIX[2][0],
		PROJECTION_MATRIX[3][3] - PROJECTION_MATRIX[3][0]
	);
	vec4 bottom = vec4(
		PROJECTION_MATRIX[0][3] + PROJECTION_MATRIX[0][1],
		PROJECTION_MATRIX[1][3] + PROJECTION_MATRIX[1][1],
		PROJECTION_MATRIX[2][3] + PROJECTION_MATRIX[2][1],
		PROJECTION_MATRIX[3][3] + PROJECTION_MATRIX[3][1]
	);
	vec4 top = vec4(
		PROJECTION_MATRIX[0][3] - PROJECTION_MATRIX[0][1],
		PROJECTION_MATRIX[1][3] - PROJECTION_MATRIX[1][1],
		PROJECTION_MATRIX[2][3] - PROJECTION_MATRIX[2][1],
		PROJECTION_MATRIX[3][3] - PROJECTION_MATRIX[3][1]
	);
	vec4 near = vec4(
		PROJECTION_MATRIX[0][3] + PROJECTION_MATRIX[0][2],
		PROJECTION_MATRIX[1][3] + PROJECTION_MATRIX[1][2],
		PROJECTION_MATRIX[2][3] + PROJECTION_MATRIX[2][2],
		PROJECTION_MATRIX[3][3] + PROJECTION_MATRIX[3][2]
	);
	vec4 far = vec4(
		PROJECTION_MATRIX[0][3] - PROJECTION_MATRIX[0][2],
		PROJECTION_MATRIX[1][3] - PROJECTION_MATRIX[1][2],
		PROJECTION_MATRIX[2][3] - PROJECTION_MATRIX[2][2],
		PROJECTION_MATRIX[3][3] - PROJECTION_MATRIX[3][2]
	);
	
	clip_line(p0, p1, left);
	clip_line(p0, p1, right);
	clip_line(p0, p1, top);
	clip_line(p0, p1, bottom);
	clip_line(p0, p1, near);
	clip_line(p0, p1, far);
	
	p0 = PROJECTION_MATRIX * p0;
	p1 = PROJECTION_MATRIX * p1;
	
	p0.xyz /= p0.w;
	p1.xyz /= p1.w;
	
	p0.w = 1.0;
	p1.w = 1.0;
	
	p0.y = -p0.y;
	p1.y = -p1.y;
	p0.xy = (p0.xy * 0.5 + 0.5) * VIEWPORT_SIZE;
	p1.xy = (p1.xy * 0.5 + 0.5) * VIEWPORT_SIZE;
	
	vec3 off = p1.xyz - p0.xyz;
	vec2 sx = normalize(off.xy) * rad;
	vec2 sy = vec2(-sx.y, sx.x);
	
	sx *= sign(UV.x);
	sy *= sign(UV.y);
	
	float l = length(off.xy);
	
	vec4 p = p0;
	p.xyz += off * max(sign(UV.x), 0.0);
	
	p.xy += (sx + sy);
	
	p.xy = (p.xy / VIEWPORT_SIZE) * 2.0 - 1.0;
	p.y = -p.y;
	//p.z = 0.0;
	
	POSITION = p;
	
	size = vec2(l * 0.5 + rad, rad);
}

void fragment() {
	vec2 p = UV * size;
	vec2 p0 = vec2(-(size.x - size.y), 0.0);
	vec2 p1 = vec2(size.x - size.y, 0.0);
	
	vec2 ba = p1 - p0;
	vec2 ca = p - p0;
	float t = dot(ca, ba) / dot(ba, ba);
	t = clamp(t, 0.0, 1.0);
	vec2 p2 = p0 + ba * t;
	
	vec2 off = p2 - p;
	float d = sqrt(off.x * off.x + off.y * off.y) - size.y;
	
	ALPHA = -d;
	ALBEDO *= COLOR.rgb;
	ALPHA_SCISSOR = 0.0;
}




"
