[gd_resource type="Shader" format=2]

[resource]
code = "shader_type spatial;
render_mode unshaded, depth_draw_alpha_prepass;

varying vec2 size;

void clip_line(inout vec4 a, inout vec4 b, vec4 plane) {
	float aw = dot(a.xyz, plane.xyz) + plane.w;
	float bw = dot(b.xyz, plane.xyz) + plane.w;
	
	a = (aw < 0.0 && bw < 0.0) ? vec4(0.0, 0.0, 1.0, 1.0) : a;
	b = (aw < 0.0 && bw < 0.0) ? vec4(0.0, 0.0, 1.0, 1.0) : b;
	
	float at = aw / (aw - bw);
	float bt = bw / (bw - aw);
	
	a = aw < 0.0 ? a + (b - a) * at : a;
	b = bw < 0.0 ? b + (a - b) * bt : b;
}

void vertex() {
	vec3 wpa = VERTEX;
	vec3 wpb = VERTEX + NORMAL;
	
	vec4 cpa = vec4(wpa, 1.0);
	vec4 cpb = vec4(wpb, 1.0);
	
	cpa = INV_CAMERA_MATRIX * cpa;
	cpb = INV_CAMERA_MATRIX * cpb;
	
	vec4 left = vec4(
		PROJECTION_MATRIX[0][3] + PROJECTION_MATRIX[0][0],
		PROJECTION_MATRIX[1][3] + PROJECTION_MATRIX[1][0],
		PROJECTION_MATRIX[2][3] + PROJECTION_MATRIX[2][0],
		PROJECTION_MATRIX[3][3] + PROJECTION_MATRIX[3][0]
	);
	vec4 right = vec4(
		PROJECTION_MATRIX[0][3] - PROJECTION_MATRIX[0][0],
		PROJECTION_MATRIX[1][3] - PROJECTION_MATRIX[1][0],
		PROJECTION_MATRIX[2][3] - PROJECTION_MATRIX[2][0],
		PROJECTION_MATRIX[3][3] - PROJECTION_MATRIX[3][0]
	);
	vec4 bottom = vec4(
		PROJECTION_MATRIX[0][3] + PROJECTION_MATRIX[0][1],
		PROJECTION_MATRIX[1][3] + PROJECTION_MATRIX[1][1],
		PROJECTION_MATRIX[2][3] + PROJECTION_MATRIX[2][1],
		PROJECTION_MATRIX[3][3] + PROJECTION_MATRIX[3][1]
	);
	vec4 top = vec4(
		PROJECTION_MATRIX[0][3] - PROJECTION_MATRIX[0][1],
		PROJECTION_MATRIX[1][3] - PROJECTION_MATRIX[1][1],
		PROJECTION_MATRIX[2][3] - PROJECTION_MATRIX[2][1],
		PROJECTION_MATRIX[3][3] - PROJECTION_MATRIX[3][1]
	);
	vec4 near = vec4(
		PROJECTION_MATRIX[0][3] + PROJECTION_MATRIX[0][2],
		PROJECTION_MATRIX[1][3] + PROJECTION_MATRIX[1][2],
		PROJECTION_MATRIX[2][3] + PROJECTION_MATRIX[2][2],
		PROJECTION_MATRIX[3][3] + PROJECTION_MATRIX[3][2]
	);
	vec4 far = vec4(
		PROJECTION_MATRIX[0][3] - PROJECTION_MATRIX[0][2],
		PROJECTION_MATRIX[1][3] - PROJECTION_MATRIX[1][2],
		PROJECTION_MATRIX[2][3] - PROJECTION_MATRIX[2][2],
		PROJECTION_MATRIX[3][3] - PROJECTION_MATRIX[3][2]
	);
	
	clip_line(cpa, cpb, left);
	clip_line(cpa, cpb, right);
	clip_line(cpa, cpb, top);
	clip_line(cpa, cpb, bottom);
	clip_line(cpa, cpb, near);
	clip_line(cpa, cpb, far);
	
	cpa = PROJECTION_MATRIX * cpa;
	cpb = PROJECTION_MATRIX * cpb;
	
	cpa.xyz /= cpa.w;
	cpb.xyz /= cpb.w;
	
	cpa.w = 1.0;
	cpb.w = 1.0;
	
	cpa.xy = (cpa.xy * 0.5 + 0.5) * VIEWPORT_SIZE;
	cpb.xy = (cpb.xy * 0.5 + 0.5) * VIEWPORT_SIZE;
	
	vec3 off = cpb.xyz - cpa.xyz;
	vec2 sx = normalize(off.xy);
	vec2 sy = vec2(-sx.y, sx.x);
	
	sx *= UV.x;
	sy *= UV.y;
	
	float l = length(off.xy);
	float r = length(sy);
	
	vec4 p = cpa;
	p.xyz += off * max(sign(UV.x), 0.0);
	
	p.xy += (sx + sy);
	
	p.xy = (p.xy / VIEWPORT_SIZE) * 2.0 - 1.0;
	
	POSITION = p;
	
	size = vec2(l * 0.5 + r, r);
	UV = UV / (abs(UV));
}

void fragment() {
	vec2 p = UV * size;
	float r = min(size.x, size.y);
	vec2 b = size - r;
	vec2 d = abs(p) - b;
	float dst1 = min(max(d.x, d.y), 0.0);
	float dst2 = length(max(d, 0.0));
	float dst = (dst1 + dst2) - r;
	
	ALPHA = -dst;
	ALBEDO *= COLOR.rgb;
	ALPHA_SCISSOR = 0.0;
}




"
